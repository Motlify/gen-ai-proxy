// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: model.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createModel = `-- name: CreateModel :one
INSERT INTO models (
    id,
    user_id,
    connection_id,
    proxy_model_id,
    provider_model_id,
    thinking,
    tools_usage,
    price_input,
    price_output
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, connection_id, proxy_model_id, provider_model_id, thinking, tools_usage, price_input, price_output, deleted_at
`

type CreateModelParams struct {
	ID              pgtype.UUID    `json:"id"`
	UserID          pgtype.UUID    `json:"user_id"`
	ConnectionID    pgtype.UUID    `json:"connection_id"`
	ProxyModelID    string         `json:"proxy_model_id"`
	ProviderModelID string         `json:"provider_model_id"`
	Thinking        bool           `json:"thinking"`
	ToolsUsage      bool           `json:"tools_usage"`
	PriceInput      pgtype.Numeric `json:"price_input"`
	PriceOutput     pgtype.Numeric `json:"price_output"`
}

func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (Model, error) {
	row := q.db.QueryRow(ctx, createModel,
		arg.ID,
		arg.UserID,
		arg.ConnectionID,
		arg.ProxyModelID,
		arg.ProviderModelID,
		arg.Thinking,
		arg.ToolsUsage,
		arg.PriceInput,
		arg.PriceOutput,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConnectionID,
		&i.ProxyModelID,
		&i.ProviderModelID,
		&i.Thinking,
		&i.ToolsUsage,
		&i.PriceInput,
		&i.PriceOutput,
		&i.DeletedAt,
	)
	return i, err
}

const getModel = `-- name: GetModel :one
SELECT id, user_id, connection_id, proxy_model_id, provider_model_id, thinking, tools_usage, price_input, price_output, deleted_at FROM models WHERE id = $1 AND user_id = $2
`

type GetModelParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetModel(ctx context.Context, arg GetModelParams) (Model, error) {
	row := q.db.QueryRow(ctx, getModel, arg.ID, arg.UserID)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConnectionID,
		&i.ProxyModelID,
		&i.ProviderModelID,
		&i.Thinking,
		&i.ToolsUsage,
		&i.PriceInput,
		&i.PriceOutput,
		&i.DeletedAt,
	)
	return i, err
}

const getModelByProxyModelID = `-- name: GetModelByProxyModelID :one
SELECT id, user_id, connection_id, proxy_model_id, provider_model_id, thinking, tools_usage, price_input, price_output, deleted_at FROM models WHERE proxy_model_id = $1 AND user_id = $2
`

type GetModelByProxyModelIDParams struct {
	ProxyModelID string      `json:"proxy_model_id"`
	UserID       pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetModelByProxyModelID(ctx context.Context, arg GetModelByProxyModelIDParams) (Model, error) {
	row := q.db.QueryRow(ctx, getModelByProxyModelID, arg.ProxyModelID, arg.UserID)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConnectionID,
		&i.ProxyModelID,
		&i.ProviderModelID,
		&i.Thinking,
		&i.ToolsUsage,
		&i.PriceInput,
		&i.PriceOutput,
		&i.DeletedAt,
	)
	return i, err
}

const listModels = `-- name: ListModels :many
SELECT id, user_id, connection_id, proxy_model_id, provider_model_id, thinking, tools_usage, price_input, price_output, deleted_at FROM models WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) ListModels(ctx context.Context, userID pgtype.UUID) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModels, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ConnectionID,
			&i.ProxyModelID,
			&i.ProviderModelID,
			&i.Thinking,
			&i.ToolsUsage,
			&i.PriceInput,
			&i.PriceOutput,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteModel = `-- name: SoftDeleteModel :exec
UPDATE models
SET deleted_at = NOW()
WHERE id = $1 AND user_id = $2
`

type SoftDeleteModelParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteModel(ctx context.Context, arg SoftDeleteModelParams) error {
	_, err := q.db.Exec(ctx, softDeleteModel, arg.ID, arg.UserID)
	return err
}

const updateModel = `-- name: UpdateModel :one
UPDATE models
SET
    proxy_model_id = $3,
    provider_model_id = $4,
    thinking = $5,
    tools_usage = $6,
    price_input = $7,
    price_output = $8
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, connection_id, proxy_model_id, provider_model_id, thinking, tools_usage, price_input, price_output, deleted_at
`

type UpdateModelParams struct {
	ID              pgtype.UUID    `json:"id"`
	UserID          pgtype.UUID    `json:"user_id"`
	ProxyModelID    string         `json:"proxy_model_id"`
	ProviderModelID string         `json:"provider_model_id"`
	Thinking        bool           `json:"thinking"`
	ToolsUsage      bool           `json:"tools_usage"`
	PriceInput      pgtype.Numeric `json:"price_input"`
	PriceOutput     pgtype.Numeric `json:"price_output"`
}

func (q *Queries) UpdateModel(ctx context.Context, arg UpdateModelParams) (Model, error) {
	row := q.db.QueryRow(ctx, updateModel,
		arg.ID,
		arg.UserID,
		arg.ProxyModelID,
		arg.ProviderModelID,
		arg.Thinking,
		arg.ToolsUsage,
		arg.PriceInput,
		arg.PriceOutput,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConnectionID,
		&i.ProxyModelID,
		&i.ProviderModelID,
		&i.Thinking,
		&i.ToolsUsage,
		&i.PriceInput,
		&i.PriceOutput,
		&i.DeletedAt,
	)
	return i, err
}
