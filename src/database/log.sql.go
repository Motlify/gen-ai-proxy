// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: log.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*)
FROM logs
WHERE
    ($1::UUID IS NULL OR user_id = $1) AND
    ($2::UUID IS NULL OR model_id = $2) AND
    ($3::UUID IS NULL OR connection_id = $3)
`

type CountLogsParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	ModelID      pgtype.UUID `json:"model_id"`
	ConnectionID pgtype.UUID `json:"connection_id"`
}

func (q *Queries) CountLogs(ctx context.Context, arg CountLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLogs, arg.UserID, arg.ModelID, arg.ConnectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLog = `-- name: CreateLog :one
INSERT INTO logs (
    user_id,
    model_id,
    request_payload,
    response_payload,
    prompt_tokens,
    completion_tokens,
    connection_id,
    type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, user_id, model_id, request_payload, response_payload, created_at, prompt_tokens, completion_tokens, connection_id, type
`

type CreateLogParams struct {
	UserID           pgtype.UUID `json:"user_id"`
	ModelID          pgtype.UUID `json:"model_id"`
	RequestPayload   []byte      `json:"request_payload"`
	ResponsePayload  []byte      `json:"response_payload"`
	PromptTokens     pgtype.Int8 `json:"prompt_tokens"`
	CompletionTokens pgtype.Int8 `json:"completion_tokens"`
	ConnectionID     pgtype.UUID `json:"connection_id"`
	Type             string      `json:"type"`
}

type CreateLogRow struct {
	ID               pgtype.UUID        `json:"id"`
	UserID           pgtype.UUID        `json:"user_id"`
	ModelID          pgtype.UUID        `json:"model_id"`
	RequestPayload   []byte             `json:"request_payload"`
	ResponsePayload  []byte             `json:"response_payload"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	PromptTokens     pgtype.Int8        `json:"prompt_tokens"`
	CompletionTokens pgtype.Int8        `json:"completion_tokens"`
	ConnectionID     pgtype.UUID        `json:"connection_id"`
	Type             string             `json:"type"`
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (CreateLogRow, error) {
	row := q.db.QueryRow(ctx, createLog,
		arg.UserID,
		arg.ModelID,
		arg.RequestPayload,
		arg.ResponsePayload,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.ConnectionID,
		arg.Type,
	)
	var i CreateLogRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ModelID,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.CreatedAt,
		&i.PromptTokens,
		&i.CompletionTokens,
		&i.ConnectionID,
		&i.Type,
	)
	return i, err
}

const getTotalInputTokensByProviderModelConnection = `-- name: GetTotalInputTokensByProviderModelConnection :many
SELECT
    p.id AS provider_id,
    p.name AS provider_name,
    m.id AS model_id,
    m.proxy_model_id AS model_name,
    cl.connection_id,
    conn.name AS connection_name,
    SUM(cl.prompt_tokens) AS total_input_tokens
FROM
    logs cl
JOIN
    models m ON cl.model_id = m.id
JOIN
    connections conn ON m.connection_id = conn.id
JOIN
    providers p ON conn.provider_id::uuid = p.id
GROUP BY
    p.id,
    p.name,
    m.id,
    m.proxy_model_id,
    cl.connection_id,
    conn.name
ORDER BY
    p.id,
    m.id,
    cl.connection_id
`

type GetTotalInputTokensByProviderModelConnectionRow struct {
	ProviderID       pgtype.UUID `json:"provider_id"`
	ProviderName     string      `json:"provider_name"`
	ModelID          pgtype.UUID `json:"model_id"`
	ModelName        string      `json:"model_name"`
	ConnectionID     pgtype.UUID `json:"connection_id"`
	ConnectionName   string      `json:"connection_name"`
	TotalInputTokens int64       `json:"total_input_tokens"`
}

func (q *Queries) GetTotalInputTokensByProviderModelConnection(ctx context.Context) ([]GetTotalInputTokensByProviderModelConnectionRow, error) {
	rows, err := q.db.Query(ctx, getTotalInputTokensByProviderModelConnection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalInputTokensByProviderModelConnectionRow
	for rows.Next() {
		var i GetTotalInputTokensByProviderModelConnectionRow
		if err := rows.Scan(
			&i.ProviderID,
			&i.ProviderName,
			&i.ModelID,
			&i.ModelName,
			&i.ConnectionID,
			&i.ConnectionName,
			&i.TotalInputTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalOutputTokensByProviderModelConnection = `-- name: GetTotalOutputTokensByProviderModelConnection :many
SELECT
    p.id AS provider_id,
    p.name AS provider_name,
    m.id AS model_id,
    m.proxy_model_id AS model_name,
    cl.connection_id,
    conn.name AS connection_name,
    SUM(cl.completion_tokens) AS total_output_tokens
FROM
    logs cl
JOIN
    models m ON cl.model_id = m.id
JOIN
    connections conn ON m.connection_id = conn.id
JOIN
    providers p ON conn.provider_id::uuid = p.id
GROUP BY
    p.id,
    p.name,
    m.id,
    m.proxy_model_id,
    cl.connection_id,
    conn.name
ORDER BY
    p.id,
    m.id,
    cl.connection_id
`

type GetTotalOutputTokensByProviderModelConnectionRow struct {
	ProviderID        pgtype.UUID `json:"provider_id"`
	ProviderName      string      `json:"provider_name"`
	ModelID           pgtype.UUID `json:"model_id"`
	ModelName         string      `json:"model_name"`
	ConnectionID      pgtype.UUID `json:"connection_id"`
	ConnectionName    string      `json:"connection_name"`
	TotalOutputTokens int64       `json:"total_output_tokens"`
}

func (q *Queries) GetTotalOutputTokensByProviderModelConnection(ctx context.Context) ([]GetTotalOutputTokensByProviderModelConnectionRow, error) {
	rows, err := q.db.Query(ctx, getTotalOutputTokensByProviderModelConnection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalOutputTokensByProviderModelConnectionRow
	for rows.Next() {
		var i GetTotalOutputTokensByProviderModelConnectionRow
		if err := rows.Scan(
			&i.ProviderID,
			&i.ProviderName,
			&i.ModelID,
			&i.ModelName,
			&i.ConnectionID,
			&i.ConnectionName,
			&i.TotalOutputTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalPriceByProviderModelConnection = `-- name: GetTotalPriceByProviderModelConnection :many
SELECT
    p.id AS provider_id,
    p.name AS provider_name,
    m.id AS model_id,
    m.proxy_model_id AS model_name,
    cl.connection_id,
    conn.name AS connection_name,
    SUM(
        (cl.prompt_tokens * m.price_input) +
        (cl.completion_tokens * m.price_output)
    )::NUMERIC AS total_price
FROM
    logs cl
JOIN
    models m ON cl.model_id = m.id
JOIN
    connections conn ON m.connection_id = conn.id
JOIN
    providers p ON conn.provider_id::uuid = p.id
GROUP BY
    p.id,
    p.name,
    m.id,
    m.proxy_model_id,
    cl.connection_id,
    conn.name
ORDER BY
    p.id,
    m.id,
    cl.connection_id
`

type GetTotalPriceByProviderModelConnectionRow struct {
	ProviderID     pgtype.UUID    `json:"provider_id"`
	ProviderName   string         `json:"provider_name"`
	ModelID        pgtype.UUID    `json:"model_id"`
	ModelName      string         `json:"model_name"`
	ConnectionID   pgtype.UUID    `json:"connection_id"`
	ConnectionName string         `json:"connection_name"`
	TotalPrice     pgtype.Numeric `json:"total_price"`
}

func (q *Queries) GetTotalPriceByProviderModelConnection(ctx context.Context) ([]GetTotalPriceByProviderModelConnectionRow, error) {
	rows, err := q.db.Query(ctx, getTotalPriceByProviderModelConnection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalPriceByProviderModelConnectionRow
	for rows.Next() {
		var i GetTotalPriceByProviderModelConnectionRow
		if err := rows.Scan(
			&i.ProviderID,
			&i.ProviderName,
			&i.ModelID,
			&i.ModelName,
			&i.ConnectionID,
			&i.ConnectionName,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalTokensByProviderModelConnection = `-- name: GetTotalTokensByProviderModelConnection :many
SELECT
    p.id AS provider_id,
    p.name AS provider_name,
    m.id AS model_id,
    m.proxy_model_id AS model_name,
    cl.connection_id,
    conn.name AS connection_name,
    SUM(cl.prompt_tokens + cl.completion_tokens) AS total_tokens
FROM
    logs cl
JOIN
    models m ON cl.model_id = m.id
JOIN
    connections conn ON m.connection_id = conn.id
JOIN
    providers p ON conn.provider_id::uuid = p.id
GROUP BY
    p.id,
    p.name,
    m.id,
    m.proxy_model_id,
    cl.connection_id,
    conn.name
ORDER BY
    p.id,
    m.id,
    cl.connection_id
`

type GetTotalTokensByProviderModelConnectionRow struct {
	ProviderID     pgtype.UUID `json:"provider_id"`
	ProviderName   string      `json:"provider_name"`
	ModelID        pgtype.UUID `json:"model_id"`
	ModelName      string      `json:"model_name"`
	ConnectionID   pgtype.UUID `json:"connection_id"`
	ConnectionName string      `json:"connection_name"`
	TotalTokens    int64       `json:"total_tokens"`
}

func (q *Queries) GetTotalTokensByProviderModelConnection(ctx context.Context) ([]GetTotalTokensByProviderModelConnectionRow, error) {
	rows, err := q.db.Query(ctx, getTotalTokensByProviderModelConnection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalTokensByProviderModelConnectionRow
	for rows.Next() {
		var i GetTotalTokensByProviderModelConnectionRow
		if err := rows.Scan(
			&i.ProviderID,
			&i.ProviderName,
			&i.ModelID,
			&i.ModelName,
			&i.ConnectionID,
			&i.ConnectionName,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogs = `-- name: ListLogs :many
SELECT id, user_id, model_id, request_payload, response_payload, created_at, prompt_tokens, completion_tokens, connection_id, type
FROM logs
WHERE
    ($1::UUID IS NULL OR user_id = $1) AND
    ($2::UUID IS NULL OR model_id = $2) AND
    ($3::UUID IS NULL OR connection_id = $3) AND
    ($4::TEXT IS NULL OR type = $4)
ORDER BY created_at DESC
LIMIT $6::BIGINT OFFSET $5::BIGINT
`

type ListLogsParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	ModelID      pgtype.UUID `json:"model_id"`
	ConnectionID pgtype.UUID `json:"connection_id"`
	Type         pgtype.Text `json:"type"`
	Offset       pgtype.Int8 `json:"offset"`
	Limit        pgtype.Int8 `json:"limit"`
}

type ListLogsRow struct {
	ID               pgtype.UUID        `json:"id"`
	UserID           pgtype.UUID        `json:"user_id"`
	ModelID          pgtype.UUID        `json:"model_id"`
	RequestPayload   []byte             `json:"request_payload"`
	ResponsePayload  []byte             `json:"response_payload"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	PromptTokens     pgtype.Int8        `json:"prompt_tokens"`
	CompletionTokens pgtype.Int8        `json:"completion_tokens"`
	ConnectionID     pgtype.UUID        `json:"connection_id"`
	Type             string             `json:"type"`
}

func (q *Queries) ListLogs(ctx context.Context, arg ListLogsParams) ([]ListLogsRow, error) {
	rows, err := q.db.Query(ctx, listLogs,
		arg.UserID,
		arg.ModelID,
		arg.ConnectionID,
		arg.Type,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLogsRow
	for rows.Next() {
		var i ListLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ModelID,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.CreatedAt,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.ConnectionID,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
