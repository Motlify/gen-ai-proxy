// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: connection.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConnection = `-- name: CreateConnection :one
INSERT INTO connections (
    user_id,
    provider_id,
    encrypted_api_key,
    name
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, provider_id, encrypted_api_key, name, created_at
`

type CreateConnectionParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	ProviderID      string      `json:"provider_id"`
	EncryptedApiKey string      `json:"encrypted_api_key"`
	Name            string      `json:"name"`
}

type CreateConnectionRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	ProviderID      string             `json:"provider_id"`
	EncryptedApiKey string             `json:"encrypted_api_key"`
	Name            string             `json:"name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) (CreateConnectionRow, error) {
	row := q.db.QueryRow(ctx, createConnection,
		arg.UserID,
		arg.ProviderID,
		arg.EncryptedApiKey,
		arg.Name,
	)
	var i CreateConnectionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderID,
		&i.EncryptedApiKey,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getConnection = `-- name: GetConnection :one
SELECT c.id, c.user_id, c.provider_id, c.encrypted_api_key, c.name, c.created_at, p.type as provider_type, c.deleted_at
FROM connections c
JOIN providers p ON p.id = c.provider_id::uuid
WHERE c.id = $1 AND c.user_id = $2 AND c.deleted_at IS NULL
`

type GetConnectionParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetConnectionRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	ProviderID      string             `json:"provider_id"`
	EncryptedApiKey string             `json:"encrypted_api_key"`
	Name            string             `json:"name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ProviderType    string             `json:"provider_type"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetConnection(ctx context.Context, arg GetConnectionParams) (GetConnectionRow, error) {
	row := q.db.QueryRow(ctx, getConnection, arg.ID, arg.UserID)
	var i GetConnectionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderID,
		&i.EncryptedApiKey,
		&i.Name,
		&i.CreatedAt,
		&i.ProviderType,
		&i.DeletedAt,
	)
	return i, err
}

const getConnectionByProvider = `-- name: GetConnectionByProvider :one
SELECT id, user_id, provider_id, encrypted_api_key, name, created_at, deleted_at FROM connections
WHERE user_id = $1 AND provider_id = $2 AND deleted_at IS NULL
`

type GetConnectionByProviderParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	ProviderID string      `json:"provider_id"`
}

func (q *Queries) GetConnectionByProvider(ctx context.Context, arg GetConnectionByProviderParams) (Connection, error) {
	row := q.db.QueryRow(ctx, getConnectionByProvider, arg.UserID, arg.ProviderID)
	var i Connection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderID,
		&i.EncryptedApiKey,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listConnections = `-- name: ListConnections :many
SELECT id, user_id, provider_id, name, created_at, deleted_at FROM connections
WHERE user_id = $1 AND deleted_at IS NULL
`

type ListConnectionsRow struct {
	ID         pgtype.UUID        `json:"id"`
	UserID     pgtype.UUID        `json:"user_id"`
	ProviderID string             `json:"provider_id"`
	Name       string             `json:"name"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListConnections(ctx context.Context, userID pgtype.UUID) ([]ListConnectionsRow, error) {
	rows, err := q.db.Query(ctx, listConnections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConnectionsRow
	for rows.Next() {
		var i ListConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.Name,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConnectionsByProviderID = `-- name: ListConnectionsByProviderID :many
SELECT id, user_id, provider_id, encrypted_api_key, name, created_at, deleted_at FROM connections
WHERE provider_id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type ListConnectionsByProviderIDParams struct {
	ProviderID string      `json:"provider_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) ListConnectionsByProviderID(ctx context.Context, arg ListConnectionsByProviderIDParams) ([]Connection, error) {
	rows, err := q.db.Query(ctx, listConnectionsByProviderID, arg.ProviderID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Connection
	for rows.Next() {
		var i Connection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.EncryptedApiKey,
			&i.Name,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteConnection = `-- name: SoftDeleteConnection :exec
UPDATE connections
SET deleted_at = NOW()
WHERE id = $1 AND user_id = $2
`

type SoftDeleteConnectionParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteConnection(ctx context.Context, arg SoftDeleteConnectionParams) error {
	_, err := q.db.Exec(ctx, softDeleteConnection, arg.ID, arg.UserID)
	return err
}
